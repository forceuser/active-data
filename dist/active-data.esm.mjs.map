{"version":3,"sources":["./src/active-data.js"],"names":["privateMap","WeakMap","initPrivate","target","set","$","get","Manager","[object Object]","options","manager","this","$$","gen","intentToRun","dataSourceKey","Symbol","observables","enabled","immediateReaction","maxIterations","watchKey","watchDeepKey","afterRun","timeLimit","getTime","performance","now","Date","callStack","reactionsToUpdate","Set","setOptions","makeObservable","bind","makeReaction","makeComputed","makeUpdatable","mapProperties","isObservable","getDataSource","observable","reaction","computed","updatable","process","env","NODE_ENV","source","propertyKeys","concat","Object","keys","forEach","propertyKey","defineProperty","enumerable","Reflect","value","assign","dataSource","constructor","Array","isArray","toUpdate","Map","computedProperties","propertyDescriptor","getOwnPropertyDescriptor","invalidateDeps","updatableState","invalidIteration","onInvalidate","valid","deps","clear","initUpdates","updatableStates","watchDeepSection","registerRead","currentKey","key","call","has","add","uninitMap","delete","size","ctrl","updateProperty","invalidatorFn","values","updatableStatesWatch","inRunSection","run","runDeferred","Proxy","context","length","apply","thisArg","argumentsList","includes","deleteProperty","fn","settings","originalFn","onUninit","id","active","undefined","uninit","uninitCall","updatableFunction","computing","console","warn","push","pop","getter","setter","configurable","action","runScheduled","iterations","Error","startTime","reactions","timeout","setTimeout","default"],"mappings":"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","sourcesContent":["/* global process */\n\nconst privateMap = new WeakMap();\nconst initPrivate = target => privateMap.set(target, {});\nconst $ = target => privateMap.get(target);\n\n/**\n * Reactive data manager that observes data changes and performs actions in response.\n * Observation is lazy, data is updated only when required.\n *\n * @param {ManagerOptions} [options] Manager options\n */\nexport class Manager {\n\tconstructor (options) {\n\t\tconst manager = this;\n\t\tinitPrivate(manager);\n\t\tconst $$ = $(manager);\n\t\t$$.gen = 0;\n\t\t$$.intentToRun = 0;\n\t\t$$.dataSourceKey = Symbol(\"dataSource\");\n\t\t$$.observables = new WeakMap();\n\t\t$$.options = {\n\t\t\tenabled: true,\n\t\t\timmediateReaction: false,\n\t\t\tmaxIterations: 10,\n\t\t\twatchKey: \"$$watch\",\n\t\t\twatchDeepKey: \"$$watchDeep\",\n\t\t\tafterRun: null,\n\t\t\ttimeLimit: 50,\n\t\t\tgetTime: typeof performance !== \"undefined\" ? () => performance.now() : () => Date.now(),\n\t\t};\n\t\t$$.callStack = [];\n\t\t$$.reactionsToUpdate = new Set();\n\n\t\tmanager.setOptions(options);\n\t\tmanager.makeObservable = manager.makeObservable.bind(manager);\n\t\tmanager.makeReaction = manager.makeReaction.bind(manager);\n\t\tmanager.makeComputed = manager.makeComputed.bind(manager);\n\t\tmanager.makeUpdatable = manager.makeUpdatable.bind(manager);\n\t\tmanager.mapProperties = manager.mapProperties.bind(manager);\n\n\t\tmanager.isObservable = manager.isObservable.bind(manager);\n\t\tmanager.getDataSource = manager.getDataSource.bind(manager);\n\t\t// aliases\n\t\tmanager.observable = manager.makeObservable;\n\t\tmanager.reaction = manager.makeReaction;\n\t\tmanager.computed = manager.makeComputed;\n\t\tmanager.updatable = manager.makeUpdatable;\n\t\t/* istanbul ignore next */\n\t\tif (typeof process !== \"undefined\" && process.env.NODE_ENV === \"test\") {\n\t\t\tmanager.$$ = $$;\n\t\t}\n\t}\n\n\t/**\n\t * Maps properties from `source` to `target`\n\t *\n\t * @param {Observable} source\n\t * @param {Observable} target\n\t * @param {(Array|String)} [propertyKeys] property keys of `source` object to map to `target` object, if not set then all keys will be mapped\n\t */\n\tmapProperties (source, target, propertyKeys) {\n\t\t[].concat(propertyKeys || Object.keys(source)).forEach(propertyKey => {\n\t\t\tObject.defineProperty(target, propertyKey, {\n\t\t\t\tenumerable: true,\n\t\t\t\tget () {\n\t\t\t\t\treturn Reflect.get(source, propertyKey, this);\n\t\t\t\t},\n\t\t\t\tset (value) {\n\t\t\t\t\treturn Reflect.set(source, propertyKey, value, this);\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Dynamically sets the options of the data manager\n\t *\n\t * @param {ManagerOptions} [options] Manager options\n\t */\n\tsetOptions (options = {}) {\n\t\t$(this).options = Object.assign($(this).options, options);\n\t}\n\n\t/**\n\t * Gets the options of the data manager\n\t *\n\t * @return {ManagerOptions} Manager options\n\t */\n\tgetOptions () {\n\t\treturn Object.assign({}, $(this).options);\n\t}\n\n\t/**\n\t * Creates {@link Observable} object for the specified dataSource\n\t *\n\t * @param {(Object|Array)} dataSource data source\n\t * @return {Observable} observable object\n\t */\n\tmakeObservable (dataSource) {\n\t\tconst manager = this;\n\t\tconst $$ = $(manager);\n\t\tif (!dataSource) {\n\t\t\treturn dataSource;\n\t\t}\n\t\tif (\n\t\t\tdataSource.constructor !== Object\n\t\t\t&&\tdataSource.constructor !== Array\n\t\t\t&&\ttypeof dataSource !== \"function\"\n\t\t) {\n\t\t\treturn dataSource;\n\t\t}\n\n\t\tif (manager.isObservable(dataSource)) {\n\t\t\treturn dataSource;\n\t\t}\n\t\tconst isArray = Array.isArray(dataSource);\n\t\tlet observable = $$.observables.get(dataSource);\n\t\tif (!observable) {\n\t\t\tconst toUpdate = new Map();\n\t\t\tconst computedProperties = {};\n\n\t\t\tObject.keys(dataSource).forEach(propertyKey => {\n\t\t\t\tconst propertyDescriptor = Object.getOwnPropertyDescriptor(dataSource, propertyKey);\n\t\t\t\tif (propertyDescriptor && typeof propertyDescriptor.get === \"function\") {\n\t\t\t\t\tcomputedProperties[propertyKey] = manager.makeUpdatable(propertyDescriptor.get);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst invalidateDeps = updatableState => {\n\t\t\t\tupdatableState.invalidIteration = true;\n\t\t\t\tupdatableState.onInvalidate && updatableState.onInvalidate();\n\t\t\t\tif (updatableState.valid) {\n\t\t\t\t\tupdatableState.valid = false;\n\t\t\t\t\tupdatableState.deps.forEach(updatableState =>\n\t\t\t\t\t\tinvalidateDeps(updatableState)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tupdatableState.deps.clear();\n\t\t\t};\n\n\t\t\tconst initUpdates = propertyKey => {\n\t\t\t\tconst updatableStates = new Set();\n\t\t\t\ttoUpdate.set(propertyKey, updatableStates);\n\t\t\t\treturn updatableStates;\n\t\t\t};\n\t\t\tlet watchDeepSection = false;\n\t\t\tconst registerRead = (updatableState, propertyKey) => {\n\t\t\t\tconst currentKey = propertyKey === $$.options.watchDeepKey ? $$.options.watchKey : propertyKey;\n\t\t\t\tif (propertyKey === $$.options.watchDeepKey) {\n\t\t\t\t\tif (watchDeepSection) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\twatchDeepSection = true;\n\t\t\t\t\tObject.keys(dataSource).forEach(key => {\n\t\t\t\t\t\tif (typeof dataSource[key] === \"object\") {\n\t\t\t\t\t\t\tconst obs = manager.makeObservable(dataSource[key]);\n\t\t\t\t\t\t\tobs[$$.options.watchDeepKey];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\twatchDeepSection = false;\n\t\t\t\t}\n\t\t\t\tif (currentKey === $$.options.watchKey) {\n\t\t\t\t\tObject.keys(computedProperties).forEach(key => {\n\t\t\t\t\t\tcomputedProperties[key].call(observable);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst updatableStates = toUpdate.get(currentKey) || initUpdates(currentKey);\n\t\t\t\tif (!updatableStates.has(updatableState)) {\n\t\t\t\t\tupdatableStates.add(updatableState);\n\t\t\t\t\tupdatableState.uninitMap.set(dataSource, updatableState => {\n\t\t\t\t\t\tupdatableStates.delete(updatableState);\n\t\t\t\t\t\tif (updatableStates.size === 0) {\n\t\t\t\t\t\t\ttoUpdate.delete(currentKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst ctrl = {toUpdate, dataSource, registerRead};\n\n\t\t\tconst updateProperty = (propertyKey) => {\n\t\t\t\tconst invalidatorFn = updatableState => invalidateDeps(updatableState);\n\t\t\t\tif (propertyKey == null) {\n\t\t\t\t\t[...ctrl.toUpdate.values()]\n\t\t\t\t\t\t.forEach(updatableStates => updatableStates.forEach(invalidatorFn));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst updatableStates = ctrl.toUpdate.get(propertyKey);\n\t\t\t\t\tupdatableStates && updatableStates.forEach(invalidatorFn);\n\t\t\t\t\tconst updatableStatesWatch = ctrl.toUpdate.get($$.options.watchKey);\n\t\t\t\t\tupdatableStatesWatch && updatableStatesWatch.forEach(invalidatorFn);\n\t\t\t\t}\n\n\t\t\t\tif (!$$.inRunSection && $$.intentToRun === 1) {\n\t\t\t\t\tif ($$.options.immediateReaction) {\n\t\t\t\t\t\tmanager.run();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmanager.runDeferred();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tobservable = new Proxy(dataSource, {\n\t\t\t\tget: (target, propertyKey, context) => {\n\t\t\t\t\tif (propertyKey === $$.dataSourceKey) {\n\t\t\t\t\t\treturn dataSource;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet updatableState;\n\t\t\t\t\tif ($$.callStack.length) {\n\t\t\t\t\t\tupdatableState = $$.callStack[$$.callStack.length - 1];\n\t\t\t\t\t\tregisterRead(updatableState, propertyKey);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tpropertyKey === $$.options.watchKey ||\n\t\t\t\t\t\tpropertyKey === $$.options.watchDeepKey\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn context;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = Reflect.get(target, propertyKey, context);\n\t\t\t\t\tif (isArray && typeof value === \"function\" && propertyKey !== \"constructor\") {\n\t\t\t\t\t\treturn new Proxy(value, {\n\t\t\t\t\t\t\tapply: (target, thisArg, argumentsList) => {\n\t\t\t\t\t\t\t\tconst updatableState = $$.callStack.length ? $$.callStack[$$.callStack.length - 1] : null;\n\t\t\t\t\t\t\t\tif (updatableState) {\n\t\t\t\t\t\t\t\t\tregisterRead(updatableState, $$.options.watchKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ([\"copyWithin\", \"fill\", \"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"].includes(propertyKey)) {\n\t\t\t\t\t\t\t\t\t$$.intentToRun++;\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tupdateProperty();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\t\t\t$$.intentToRun--;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn target.apply(dataSource, argumentsList);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof value === \"object\") {\n\t\t\t\t\t\treturn manager.makeObservable(value);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tset: (target, propertyKey, value, context) => {\n\n\t\t\t\t\tconst oldValue = Reflect.get(target, propertyKey, context);\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalue !== oldValue ||\n\t\t\t\t\t\t(Array.isArray(target) && propertyKey === \"length\")\n\t\t\t\t\t) {\n\t\t\t\t\t\t$$.intentToRun++;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tReflect.set(target, propertyKey, value, context);\n\t\t\t\t\t\t\tupdateProperty(propertyKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t$$.intentToRun--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tdefineProperty: (target, propertyKey, propertyDescriptor) => {\n\t\t\t\t\tif (propertyDescriptor && typeof propertyDescriptor.get === \"function\") {\n\t\t\t\t\t\tcomputedProperties[propertyKey] = manager.makeUpdatable(propertyDescriptor.get);\n\t\t\t\t\t}\n\t\t\t\t\treturn Reflect.defineProperty(target, propertyKey, propertyDescriptor);\n\t\t\t\t},\n\t\t\t\tdeleteProperty: (target, propertyKey) => {\n\t\t\t\t\t$$.intentToRun++;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (propertyKey in computedProperties) {\n\t\t\t\t\t\t\tdelete computedProperties[propertyKey];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tupdateProperty(propertyKey);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\t$$.intentToRun--;\n\t\t\t\t\t}\n\t\t\t\t\treturn Reflect.deleteProperty(target, propertyKey);\n\t\t\t\t},\n\t\t\t});\n\t\t\t$$.observables.set(dataSource, observable);\n\t\t}\n\t\treturn observable;\n\t}\n\n\t/**\n\t * Creates {@link UpdatableFunction}\n\t * Used for internal purposes\n\t *\n\t * @param {Function} fn function that will be called from {@link UpdatableFunction}\n\t * @param {UpdatableSettings} settings settings for updatable function\n\t * @return {UpdatableFunction}\n\t */\n\tmakeUpdatable (fn, settings = {}) {\n\t\tif (fn.originalFn) {\n\t\t\treturn fn;\n\t\t}\n\t\tconst onInvalidate = settings.onInvalidate;\n\t\tconst onUninit = settings.onUninit;\n\n\t\tconst manager = this;\n\t\tconst $$ = $(manager);\n\n\t\tconst updatableState = {\n\t\t\tid: ++$$.gen,\n\t\t\tactive: true,\n\t\t\tvalid: false,\n\t\t\tonInvalidate,\n\t\t\tonUninit,\n\t\t\tvalue: undefined,\n\t\t\tdeps: new Set(),\n\t\t\tuninitMap: new Map(),\n\t\t\tuninit: () => {\n\t\t\t\t[...updatableState.uninitMap.values()].forEach(uninitCall => uninitCall(updatableState));\n\t\t\t\tupdatableState.uninitMap.clear();\n\t\t\t},\n\t\t};\n\n\t\tconst updatableFunction = function () {\n\t\t\tif (!updatableState.active) {\n\t\t\t\treturn fn.call(this, this);\n\t\t\t}\n\t\t\tif (updatableState.computing) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Detected cross reference inside computed properties!` +\n\t\t\t\t\t\t` \"undefined\" will be returned to prevent infinite loop`\n\t\t\t\t);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif ($$.callStack.length) {\n\t\t\t\tupdatableState.deps.add($$.callStack[$$.callStack.length - 1]);\n\t\t\t}\n\n\t\t\tif (updatableState.valid) {\n\t\t\t\treturn updatableState.value;\n\t\t\t}\n\t\t\tupdatableState.computing = true;\n\t\t\tupdatableState.uninit();\n\n\t\t\t$$.callStack.push(updatableState);\n\t\t\ttry {\n\t\t\t\tconst context = this ? $$.observables.get(this) || this : null;\n\t\t\t\tupdatableState.invalidIteration = false;\n\t\t\t\tconst value = fn.call(context, context);\n\n\t\t\t\tupdatableState.valid = !updatableState.invalidIteration; // check if it was invalidated inside call\n\t\t\t\tupdatableState.value = value;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tupdatableState.computing = false;\n\t\t\t\t$$.callStack.pop();\n\t\t\t}\n\t\t};\n\t\tupdatableFunction.uninit = () => {\n\t\t\tupdatableState.uninit();\n\t\t\tupdatableState.active = false;\n\t\t\tonUninit && onUninit();\n\t\t};\n\t\tupdatableFunction.originalFn = fn;\n\t\treturn updatableFunction;\n\t}\n\n\t/**\n\t * Creates computed property\n\t *\n\t * @param {Object} target The object for which the calculated property will be created\n\t * @param {String} propertyKey Name of calculated property\n\t * @param {Function} getter The function to be executed when accessing the property\n\t * @param {Function} [setter] The function that will be executed when setting the value of the property\n\t */\n\tmakeComputed (target, propertyKey, getter, setter) {\n\t\tObject.defineProperty(target, propertyKey, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tget: this.makeUpdatable(getter),\n\t\t\tset: setter,\n\t\t});\n\t}\n\n\t/**\n\t * Creates {@link UpdatableFunction} that will be automatically\n\t * executed when one of it's dependencies are changed\n\t *\n\t * @param {Function} call\n\t * Function to call {@link UpdatableFunction}\n\t * 'call' will be executed when some of {@link Observable} that was used on previous call\n\t * are changed\n\t *\n\t * @param {Boolean} run\n\t * Run function immediately after it's registration\n\t * If {@link ManagerOptions.immediateReaction} is not set\n\t * then it will be called on the next tick.\n\t * @return {UpdatableFunction}\n\t */\n\tmakeReaction (call, run = true) {\n\t\tconst manager = this;\n\t\tconst $$ = $(manager);\n\t\tconst updatable = manager.makeUpdatable(call, {\n\t\t\tonInvalidate: () => $$.reactionsToUpdate.add(updatable),\n\t\t\tonUninit: () => $$.reactionsToUpdate.delete(updatable),\n\t\t});\n\t\t$$.reactionsToUpdate.add(updatable);\n\t\tif (run) {\n\t\t\tif ($$.options.immediateReaction) {\n\t\t\t\tmanager.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmanager.runDeferred();\n\t\t\t}\n\t\t}\n\t\treturn updatable;\n\t}\n\n\t/**\n\t * Returns original source of {@link Observable}\n\t *\n\t * @return {(Object|Array)}\n\t */\n\tgetDataSource (target) {\n\t\treturn target[$(this).dataSourceKey];\n\t}\n\n\t/**\n\t * Checks if the object is {@link Observable}\n\t *\n\t * @param {(Observable|Object|Array)} target\n\t */\n\tisObservable (target) {\n\t\treturn target[$(this).dataSourceKey] != null;\n\t}\n\n\t/**\n\t * Executes all reactions that marked with invalid state\n\t *\n\t * @param {Function} [action]\n\t * Changes of {@link Observable} that happens inside 'action' function\n\t * will not trigger immediate execution of dependent reactions\n\t * If {@link ManagerOptions.immediateReaction} is set then reactions\n\t * will be executed after exiting the 'action' function\n\t */\n\trun (action) {\n\t\tconst manager = this;\n\t\tconst $$ = $(manager);\n\t\tif (!$$.options.enabled) {\n\t\t\treturn;\n\t\t}\n\t\t$$.inRunSection = true;\n\t\ttry {\n\t\t\tif (typeof action === \"function\") {\n\t\t\t\taction();\n\t\t\t}\n\t\t\t$$.runScheduled = false;\n\t\t\tlet iterations = 0;\n\t\t\twhile ($$.reactionsToUpdate.size) {\n\t\t\t\tif (iterations > $$.options.maxIterations) {\n\t\t\t\t\t$$.reactionsToUpdate.clear();\n\t\t\t\t\tthrow new Error(\"Max iterations exceeded!\");\n\t\t\t\t}\n\t\t\t\titerations++;\n\t\t\t\tconst startTime = $$.options.getTime();\n\t\t\t\tconst reactions = [...$$.reactionsToUpdate.values()];\n\t\t\t\tfor (const updatable of reactions) {\n\t\t\t\t\t$$.reactionsToUpdate.delete(updatable);\n\t\t\t\t\tupdatable();\n\t\t\t\t\tif ($$.options.getTime() - startTime >= $$.options.timeLimit) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($$.reactionsToUpdate.size) {\n\t\t\t\t\tmanager.runDeferred();\n\t\t\t\t}\n\t\t\t}\n\t\t\ttypeof $$.options.afterRun === \"function\" && $$.options.afterRun();\n\t\t}\n\t\tfinally {\n\t\t\t$$.inRunSection = false;\n\t\t}\n\t}\n\n\t/**\n\t * Executes all reactions that marked as invalid\n\t * Unlike {@link run}, 'runDeferred' makes it not immediately but after 'timeout'\n\t *\n\t * @param {Function} [action] changes of {@link Observable} that happens inside 'action' function\n\t * will not trigger immediate execution of dependent reactions\n\t * @param {Number} [timeout=0] reactions execution delay\n\t */\n\trunDeferred (action, timeout = 0) {\n\t\tconst manager = this;\n\t\tconst $$ = $(manager);\n\t\tif (!$$.options.enabled) {\n\t\t\treturn;\n\t\t}\n\t\t$$.inRunSection = true;\n\t\ttry {\n\t\t\tif (!$$.runScheduled) {\n\t\t\t\t$$.runScheduled = setTimeout(() => this.run(), timeout);\n\t\t\t}\n\t\t\tif (typeof action === \"function\") {\n\t\t\t\taction();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t$$.inRunSection = false;\n\t\t}\n\t}\n}\n\nManager.default = new Manager();\nManager.default.Manager = Manager;\n\nexport default Manager.default;\nexport const observable = Manager.default.observable;\nexport const reaction = Manager.default.reaction;\nexport const computed = Manager.default.computed;\nexport const updatable = Manager.default.updatable;\n\n/**\n * @typedef ManagerOptions\n * @name ManagerOptions\n * @type {Object}\n * @property {Boolean} [immediateReaction=false] if set to `true` reactions will be executed immediately on same event loop\n * otherwise it will be executed after zero timeout (on next event loop)\n * @property {Boolean} [enabled=true] - state of data manager, if it is disabled then reactions will not be executed\n */\n\n/**\n * @typedef Observable\n * @name Observable\n * @description Object or array that will be observed for changes.\n * When the property of type {@link Object} or {@link Array} of {@link Observable}\n * are accessed it automaticaly becomes {@link Observable}\n */\n\n/**\n * @typedef UpdatableFunction\n * @name UpdatableFunction\n * @property {Function} uninit\n * @description function that caches result of its execution and returns cached value if function state is valid\n * function state can be invalidated if some of {@link Observable} objects that were accessed on previous call are changed\n */\n\n/**\n  * @typedef UpdatableSettings\n  * @name UpdatableSettings\n  * @type {Object}\n  * @property {Function} onInvalidate callback function that will be executed when UpdatableState of {@link UpdatableFunction} becomes invalid\n  * @property {Function} onUninit callback function that will be executed after {@link UpdatableFunction#uninit} is called\n  * @description Settings to create {@link UpdatableFunction}\n  */\n"]}